/*
 * Copyright MapStruct Authors.
 *
 * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
 */
package io.icure.kmap

import org.mapstruct.CollectionMappingStrategy
import org.mapstruct.InjectionStrategy
import org.mapstruct.MappingInheritanceStrategy
import org.mapstruct.NullValueCheckStrategy
import org.mapstruct.NullValueMappingStrategy
import org.mapstruct.NullValuePropertyMappingStrategy
import org.mapstruct.ReportingPolicy
import kotlin.annotation.Retention
import kotlin.reflect.KClass

/**
 * Marks an interface or abstract class as a mapper and activates the generation of a implementation of that type via
 * MapStruct.
 *
 * @author Gunnar Morling
 */
@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)
@Retention
annotation class Mapper(
    /**
     * Other mapper types used by this mapper. May be hand-written classes or other mappers generated by MapStruct. No
     * cycle between generated mapper classes must be created.
     *
     * @return The mapper types used by this mapper.
     */
    val uses: Array<KClass<*>> = [],
    /**
     * Additional types for which an import statement is to be added to the generated mapper implementation class.
     * This allows to refer to those types from within mapping expressions given via [Mapping.expression],
     * [Mapping.defaultExpression] or using
     * their simple name rather than their fully-qualified name.
     *
     * @return classes to add in the imports of the generated implementation.
     */
    val imports: Array<KClass<*>> = [],
    /**
     * How unmapped properties of the source type of a mapping should be
     * reported. The method overrides an unmappedSourcePolicy set in a central
     * configuration set by [.config]
     *
     * @return The reporting policy for unmapped source properties.
     *
     * @since 1.3
     */
    val unmappedSourcePolicy: ReportingPolicy = ReportingPolicy.IGNORE,
    /**
     * How unmapped properties of the target type of a mapping should be
     * reported. The method overrides an unmappedTargetPolicy set in a central
     * configuration set by [.config]
     *
     * @return The reporting policy for unmapped target properties.
     */
    val unmappedTargetPolicy: ReportingPolicy = ReportingPolicy.WARN,
    /**
     * How lossy (narrowing) conversion, for instance long to integer should be
     * reported. The method overrides an typeConversionPolicy set in a central
     * configuration set by [.config]
     *
     * @since 1.3
     *
     * @return The reporting policy for unmapped target properties.
     */
    val typeConversionPolicy: ReportingPolicy = ReportingPolicy.IGNORE,
    /**
     * Specifies the component model to which the generated mapper should
     * adhere. Supported values are
     *
     *  *  `default`: the mapper uses no component model, instances are
     * typically retrieved via [Mappers.getMapper]
     *  *
     * `cdi`: the generated mapper is an application-scoped CDI bean and
     * can be retrieved via `@Inject`
     *  *
     * `spring`: the generated mapper is a Spring bean and
     * can be retrieved via `@Autowired`
     *  *
     * `jsr330`: the generated mapper is annotated with `@javax.inject.Named` and
     * `@Singleton`, and can be retrieved via `@Inject`
     *
     * The method overrides an unmappedTargetPolicy set in a central configuration set
     * by [.config]
     *
     * @return The component model for the generated mapper.
     */
    val componentModel: String = "default",
    /**
     * Specifies the name of the implementation class. The `<CLASS_NAME>` will be replaced by the
     * interface/abstract class name.
     *
     *
     * Defaults to postfixing the name with `Impl`: `<CLASS_NAME>Impl`
     *
     * @return The implementation name.
     * @see .implementationPackage
     */
    val implementationName: String = "<CLASS_NAME>Impl",
    /**
     * Specifies the target package for the generated implementation. The `<PACKAGE_NAME>` will be replaced by the
     * interface's or abstract class' package.
     *
     *
     * Defaults to using the same package as the mapper interface/abstract class
     *
     * @return the implementation package.
     * @see .implementationName
     */
    val implementationPackage: String = "<PACKAGE_NAME>",
    /**
     * A class annotated with [MapperConfig] which should be used as configuration template. Any settings given
     * via [Mapper] will take precedence over the settings from the referenced configuration source. The list of
     * referenced mappers will contain all mappers given via [Mapper.uses] and [MapperConfig.uses].
     *
     * @return A class which should be used as configuration template.
     */
    val config: KClass<*> = Unit::class,
    /**
     * The strategy to be applied when propagating the value of collection-typed properties. By default, only JavaBeans
     * accessor methods (setters or getters) will be used, but it is also possible to invoke a corresponding adder
     * method for each element of the source collection (e.g. `orderDto.addOrderLine()`).
     *
     *
     * Any setting given for this attribute will take precedence over [MapperConfig.collectionMappingStrategy],
     * if present.
     *
     * @return The strategy applied when propagating the value of collection-typed properties.
     */
    val collectionMappingStrategy: CollectionMappingStrategy = CollectionMappingStrategy.ACCESSOR_ONLY,
    /**
     * The strategy to be applied when `null` is passed as source argument value to the methods of this mapper.
     * If no strategy is configured, the strategy given via [MapperConfig.nullValueMappingStrategy] will be
     * applied, using [NullValueMappingStrategy.RETURN_NULL] by default.
     *
     * @return The strategy to be applied when `null` is passed as source value to the methods of this mapper.
     */
    val nullValueMappingStrategy: NullValueMappingStrategy = NullValueMappingStrategy.RETURN_NULL,
    /**
     * The strategy to be applied when a source bean property is `null` or not present. If no strategy is
     * configured, the strategy given via [MapperConfig.nullValuePropertyMappingStrategy] will be applied,
     * [NullValuePropertyMappingStrategy.SET_TO_NULL] will be used by default.
     *
     * @since 1.3
     *
     * @return The strategy to be applied when `null` is passed as source property value or the source property
     * is not present.
     */
    val nullValuePropertyMappingStrategy: NullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_NULL,
    /**
     * The strategy to use for applying method-level configuration annotations of prototype methods in the interface
     * specified with [.config]. Annotations that can be inherited are for example [Mapping],
     * [IterableMapping], [MapMapping], or [BeanMapping].
     *
     *
     * If no strategy is configured, the strategy given via [MapperConfig.mappingInheritanceStrategy] will be
     * applied, using [MappingInheritanceStrategy.EXPLICIT] as default.
     *
     * @return The strategy to use for applying `@Mapping` configurations of prototype methods in the interface
     * specified with [.config].
     */
    val mappingInheritanceStrategy: MappingInheritanceStrategy = MappingInheritanceStrategy.EXPLICIT,
    /**
     * Determines when to include a null check on the source property value of a bean mapping.
     *
     * Can be overridden by the one on [MapperConfig], [BeanMapping]  or [Mapping].
     *
     * @return strategy how to do null checking
     */
    val nullValueCheckStrategy: NullValueCheckStrategy = NullValueCheckStrategy.ON_IMPLICIT_CONVERSION,
    /**
     * Determines whether to use field or constructor injection. This is only used on annotated based component models
     * such as CDI, Spring and JSR 330.
     *
     * If no strategy is configured, [InjectionStrategy.FIELD] will be used as default.
     *
     * @return strategy how to inject
     */
    val injectionStrategy: InjectionStrategy = InjectionStrategy.FIELD,
    /**
     * If MapStruct could not find another mapping method or apply an automatic conversion it will try to generate a
     * sub-mapping method between the two beans. If this property is set to `true` MapStruct will not try to
     * automatically generate sub-mapping methods.
     *
     *
     * Can be configured by the [MapperConfig.disableSubMappingMethodsGeneration] as well.
     *
     *
     * Note: If you need to use `disableSubMappingMethodsGeneration` please contact the MapStruct team at
     * [mapstruct.org](http://mapstruct.org) or
     * [github.com/mapstruct/mapstruct](https://github.com/mapstruct/mapstruct) to share what problem you
     * are facing with the automatic sub-mapping generation.
     *
     * @return whether the automatic generation of sub-mapping methods is disabled
     *
     * @since 1.2
     */
    val disableSubMappingMethodsGeneration: Boolean = false,

)
